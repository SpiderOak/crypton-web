<%
  title="Crypton.io | Containers"
  currentBody="body-docs"
  selected=""
%>
<div class="wrapper no-bg">
  <div class="container">
    <div class="row">
      <div class="box left col1 block">
        <h2 class="dark left col1">Containers</h2>
        <p>
          Data in Crypton is treated as a traditional object database.
          Containers are append-only stores that are transparently encrypted on the client side.</p>
        <p>
          Containers are identified by keys such as "diary" in the example below.
          Any string is allowed. From the server's perspective, container names (and of course their contents) are unreadable.
        </p>
        <p>
          If the data set is going to grow very large,
          partitioning data across containers and
          lazy loading them as you need them can help with app load time.
          One simple tactic for partitioning data among containers
          is to keep app metadata all in one container,
          and keep bulky binary data (images, videos, long text strings, whatever)
          in many other containers. Metadata is usually very small, and can load quickly.
          For example, a diary app might have a single metadata container with a list of entries -
          each containing an ID, title, date, keywords, and possibly other basic attributes.
          Each entry body would be stored as a separate container
          and loaded via a reference from the metadata container.
        </p>

        <p><strong>session.load(containerName, callback)</strong></p>
        <p>
          If not cached on the client, this method will ask the server for
          all container records for the given <code>containerName</code>.
          If the current session's account is allowed access to this data,
          it is sent to the client and decrypted.
          After decryption, all records (differences between versions of said container)
          are used to rebuild the container state. This is done transparently.
        </p>
        <pre class="examples"><code data-language="javascript">session.load('diary', function (err, diary) {
  // diary is a container, specific to the current account
  window.diary = diary;
});</code></pre>

        <p><strong>session.create(containerName, callback)</strong></p>
        <p>
          <code>session.load</code> will callback with an error
          if the given <code>containerName</code> does not exist.
          <code>session.create</code> will create a blank container
          and save its initial state to the server.
        </p>
      <pre class="examples"><code data-language="javascript">session.load('diary', function (err, container) {
  if (err) {
    session.create('diary', function (err, container) {
      window.diary = container;
      doSomethingWithContainer();
    });
    return;
  }

  window.diary = container;
  doSomethingWithContainer();
});</code></pre>

      <p><strong>container.add(key, callback)</strong></p>
      <p>
        Add an empty object to said container at <code>key</code>.
        Will callback with an error if <code>key</code> already exists.
      </p>
      <pre class="examples"><code data-language="javascript">diary.add('entries', function () {
  // diary now has an entries object
});</code></pre>

      <p><strong>container.get(key, callback)</strong></p>
      <p>
        Retreive an object from said container.
        This is a shortcut to <code>container.keys[key]</code>,
        but this method should be used in case the underlying data structure changes.
      </p>
      <p>
        Container objects may contain any type of JavaScript primitive
        (object, array, string, number).
        Binary data is not yet supported (but you may encode it to a string).
      </p>
      <pre class="examples"><code data-language="javascript">diary.add('entries', function () {
  // saves an error check below
  // worst case scenario: key already exists and will not be overwritten
  diary.get('entries', function (err, entries) {
    window.entries = entries;
    // it is impotant to note that reassigning the object
    // will overwrite its reference to the container
    // (for example, saying window.entries = {} later will not affect the object itself)
  });
});</code></pre>

      <p><strong>container.save(callback)</strong></p>
      <p>
        Looks at the container's objects for changes since its last known version,
        creates a delta, encrypts the delta, and saves it to the server.
      </p>
      <pre class="examples"><code data-language="javascript">var id = entries.length;

var newEntry = {
  id: id,
  title: 'Adventures with Crypto'
};

entries[id] = newEntry;

entries.save(function (err) {
  if (err) {
    // alert the user
    return;
  }

  // update UI
});</code></pre>
      <p>
        Let's add some more content to this entry.
        We'll store the text content separately from the metadata,
        in its own one-off container.
      </p>
      <pre class="examples"><code data-language="javascript">var text = 'Dear diary,\n\n
Today, I transparently encrypted data with Crypton and it was dreamy.';
var textContainerName = 'entry:' + id;

session.create(textContainerName, function (err, textContainer) {
  textContainer.add('entry', function () {
    textContainer.get('entry', function (err, entry) {
      entry.body = text;

      textContainer.save(function (err) {
        if (err) {
          // alert the user
          return;
        }

        // now update a metadata container
      });
    });
  });
});</code></pre>
      </div>
    </div>
  </div>
</div>

